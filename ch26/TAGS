
c:/Projects/Haskell/haskellbook-solutions/ch26/wrapItUp.hs,23
embedded embedded4,5

c:/Projects/Haskell/haskellbook-solutions/ch26/sPrintIncAccum.hs,35
sPrintIncAccum sPrintIncAccum2,3

c:/Projects/Haskell/haskellbook-solutions/ch26/scottyHelloWorld\src\Main.hs,37
module Main Main2,3
main main8,9

c:/Projects/Haskell/haskellbook-solutions/ch26/scottyHelloWorld\Setup.hs,15
main main1,2

c:/Projects/Haskell/haskellbook-solutions/ch26/rShow.hs,17
rShow rShow2,3

c:/Projects/Haskell/haskellbook-solutions/ch26/rPrintAndInc.hs,31
rPrintAndInc rPrintAndInc2,3

c:/Projects/Haskell/haskellbook-solutions/ch26/rDec.hs,32
rDec rDec2,3
rDec' rDec'5,6

c:/Projects/Haskell/haskellbook-solutions/ch26/MyStateT.hs,359
module MyStateT MyStateT2,3
newtype StateT StateT4,5
  StateT { runStateT runStateT5,6
instance Functor Functor m => Functor (StateT s m)7,8
  fmap fmap8,9
instance Monad Monad m => Applicative (StateT s m)11,12
  pure pure12,13
  (<(<*>)14,15
instance Monad Monad m => Monad (StateT s m)20,21
  return return21,22
  (S(StateTsmas)22,23

c:/Projects/Haskell/haskellbook-solutions/ch26/MyReaderT.hs,385
module MyReaderTMyReaderT0,1
newtype ReaderT ReaderT4,5
  ReaderT { runReaderT runReaderT5,6
instance Functor Functor m => Functor (ReaderT r m)7,8
  fmap fmap8,9
instance Applicative Applicative m => Applicative (ReaderT r m)10,11
  pure pure11,12
  (R(ReaderTf)13,14
instance Monad Monad m => Monad (ReaderT r m)15,16
  return return16,17
  (R(ReaderTrma)17,18

c:/Projects/Haskell/haskellbook-solutions/ch26/monadIoInstances.hs,559
newtype MaybeT MaybeT5,6
  MaybeT { runMaybeT runMaybeT6,7
instance Functor Functor m => Functor (MaybeT m)8,9
  fmap fmap9,10
instance Applicative Applicative m => Applicative (MaybeT m)11,12
  pure pure12,13
  (<(<*>)13,14
instance Monad Monad m => Monad (MaybeT m)16,17
  return return17,18
  (>(>>=)18,19
instance (M(MonadIO m) => MonadIO (MaybeT m)24,25
  liftIO liftIO25,26
instance (M(MonadIO m) => MonadIO (ReaderT r m)27,28
  liftIO liftIO28,29
instance (M(MonadIO m) => MonadIO (StateT s m)30,31
  liftIO liftIO31,32

c:/Projects/Haskell/haskellbook-solutions/ch26/liftMore\src\Main.hs,308
module Main Main0,1
newtype EitherT EitherT5,6
  EitherT { runEitherT runEitherT6,7
instance MonadTrans MonadTrans (EitherT e)8,9
  lift lift9,10
newtype StateT StateT12,13
  StateT { runStateT runStateT13,14
instance MonadTrans MonadTrans (StateT s)15,16
  lift lift16,17
main main18,19

c:/Projects/Haskell/haskellbook-solutions/ch26/liftMore\Setup.hs,15
main main1,2

c:/Projects/Haskell/haskellbook-solutions/ch26/hypoEx.hs,211
newtype ReaderT ReaderT0,1
  ReaderT { runReaderT runReaderT1,2
newtype MaybeT MaybeT3,4
  MaybeT { runMaybeT runMaybeT4,5
readerTMaybe readerTMaybe6,7
maybeTReader maybeTReader9,10
main main12,13

c:/Projects/Haskell/haskellbook-solutions/ch26/fixTheCode.hs,75
isValid isValid4,5
maybeExcite maybeExcite7,8
doExcite doExcite13,14

c:/Projects/Haskell/haskellbook-solutions/ch26/eitherT.hs,423
newtype EitherT EitherT0,1
  EitherT { runEitherT runEitherT1,2
instance Functor Functor m => Functor (EitherT e m)3,4
  fmap fmap4,5
instance Applicative Applicative m => Applicative (EitherT e m)6,7
  pure pure7,8
  f f9,10
instance Monad Monad m => Monad (EitherT e m)11,12
  return return12,13
  (E(EitherTmea)14,15
swapEither swapEither21,22
swapEitherT swapEitherT25,26
eitherT eitherT30,31
