
==================== FINAL INTERFACE ====================
2018-06-30 23:49:05.3620316 UTC

interface main@main:Main 8002
  interface hash: c0f354ae5be9a65bbb0651306051c984
  ABI hash: 4ed279a940268bcce6a3f85ac2110a50
  export-list hash: 853eedc5703fc7ffa9d7b2942440665a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c82434e2ac63da4330a7402e5c55ef11
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
  Main.Identity{Main.Identity}
module dependencies:
package dependencies: QuickCheck-2.10.1@QuickCheck-2.10.1-Ggpy3L8paKw6igDgSNY8Eu
                      Win32-2.3.1.1@Win32-2.3.1.1 array-0.5.1.1@array-0.5.1.1
                      base-4.9.1.0
                      base-orphans-0.7@base-orphans-0.7-8S4ts20sdDDGKcsJJT3Axg
                      bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      checkers-0.4.10@checkers-0.4.10-Dd1qhNuRzsFEdKKGMYMMLZ
                      comonad-5.0.3@comonad-5.0.3-7e7Dvj5mDwC6VSBGKQt4ld
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      distributive-0.5.3@distributive-0.5.3-9y9UA74GwyF5GCJecVidPm
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.7.0@hashable-1.2.7.0-L5GefWpcApuJCHCkER8VIP
                      integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.4.0@primitive-0.6.4.0-GNLAlD4yr117oBmLUp0dWo
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      semigroupoids-5.2.2@semigroupoids-5.2.2-FoSz5DKnSci4YxRGXzffyK
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD
                      tf-random-0.5@tf-random-0.5-8zb9gy6kAR08bzNKGLuVb6
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-IuFogs8HAVUJBWVNMhtssu
                      unordered-containers-0.2.9.0@unordered-containers-0.2.9.0-5iQwwbfCBro3IwoUhw2qtd
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-4.9.1.0:Text.Show.Functions
         base-orphans-0.7@base-orphans-0.7-8S4ts20sdDDGKcsJJT3Axg:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         checkers-0.4.10@checkers-0.4.10-Dd1qhNuRzsFEdKKGMYMMLZ:Test.QuickCheck.Checkers
         hashable-1.2.7.0@hashable-1.2.7.0-L5GefWpcApuJCHCkER8VIP:Data.Hashable.Generic
         text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD:Data.Text
         text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD:Data.Text.Lazy
         text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Biff
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Clown
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Flip
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Join
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Joker
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Product
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Tannen
                         bifunctors-5.5.2@bifunctors-5.5.2-Hwf98HfFabd43rYOzRKklH:Data.Bifunctor.Wrapped
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0@primitive-0.6.4.0-GNLAlD4yr117oBmLUp0dWo:Control.Monad.Primitive
                         primitive-0.6.4.0@primitive-0.6.4.0-GNLAlD4yr117oBmLUp0dWo:Data.Primitive.ByteArray
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD:Data.Text
                         text-1.2.3.0@text-1.2.3.0-G7rFyq7U84i6Y0Mxln7xWD:Data.Text.Lazy
                         unordered-containers-0.2.9.0@unordered-containers-0.2.9.0-5iQwwbfCBro3IwoUhw2qtd:Data.HashMap.Base
import  -/  QuickCheck-2.10.1@QuickCheck-2.10.1-Ggpy3L8paKw6igDgSNY8Eu:Test.QuickCheck 6681bdb715fc496fdb1eb548079b564a
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.Traversable 078621b399ac9374b02f3f2ce55a08e9
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  checkers-0.4.10@checkers-0.4.10-Dd1qhNuRzsFEdKKGMYMMLZ:Test.QuickCheck.Checkers 316cccd07fca2bc0f53352d0b4362ab1
import  -/  checkers-0.4.10@checkers-0.4.10-Dd1qhNuRzsFEdKKGMYMMLZ:Test.QuickCheck.Classes bd20a24e85abf749ed0f0ac4b93e1712
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
eff7c7b3f1099a43bf7f6565801d2d6e
  $fEqIdentity ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Main.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Main.Identity a)
                  (Main.$fEqIdentity_$c== @ a $dEq)
                  (Main.$fEqIdentity_$c/= @ a $dEq) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fEqIdentity_$c/= ::
    GHC.Classes.Eq a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes./=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fEqIdentity_$c== ::
    GHC.Classes.Eq a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.==
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity :: Data.Foldable.Foldable Main.Identity
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fFoldableIdentity_$cfold
                  Main.$fFoldableIdentity_$cfoldMap
                  Main.$fFoldableIdentity_$cfoldr
                  Main.$fFoldableIdentity_$cfoldr
                  Main.$fFoldableIdentity_$cfoldl
                  Main.$fFoldableIdentity_$cfoldl
                  Main.$fFoldableIdentity_$cfoldr1
                  Main.$fFoldableIdentity_$cfoldr1
                  Main.$fFoldableIdentity_$ctoList
                  Main.$fFoldableIdentity_$cnull
                  Main.$fFoldableIdentity_$clength
                  Main.$fFoldableIdentity_$celem
                  Main.$fFoldableIdentity_$cmaximum
                  Main.$fFoldableIdentity_$cmaximum
                  Main.$fFoldableIdentity_$csum
                  Main.$fFoldableIdentity_$csum -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity1 ::
    GHC.Num.Num a => Main.Identity a -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Main.Identity a) -> eta) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity2 ::
    GHC.Classes.Ord a => Main.Identity a -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) (eta :: Main.Identity a) ->
                 eta) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity3 ::
    (a -> a -> a) -> Main.Identity a -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (f :: a -> a -> a) (xs :: Main.Identity a) -> xs) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity4 ::
    GHC.Base.Monoid m => Main.Identity m -> Main.Identity m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ m ($dMonoid :: GHC.Base.Monoid m) (ds :: Main.Identity m) ->
                 ds) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$celem ::
    GHC.Classes.Eq a => a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 \ (ds :: Main.Identity a) ->
                 f ds `cast` (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cfold ::
    GHC.Base.Monoid m => Main.Identity m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFoldableIdentity4
                  `cast`
                (forall (m :: <*>_N).
                 <GHC.Base.Monoid m>_R
                 ->_R <Main.Identity m>_R
                 ->_R Main.N:Identity[0] <m>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Main.Identity a -> m
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (ds :: Main.Identity a) ->
                 f ds `cast` (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cfoldl ::
    (b -> a -> b) -> b -> Main.Identity a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ b @ a (f :: b -> a -> b) (z :: b) (t1 :: Main.Identity a) ->
                 f z t1 `cast` (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cfoldr ::
    (a -> b -> b) -> b -> Main.Identity a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a @ b (f :: a -> b -> b) (z :: b) (t1 :: Main.Identity a) ->
                 f t1 `cast` (Main.N:Identity[0] <a>_R) z) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cfoldr1 ::
    (a -> a -> a) -> Main.Identity a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFoldableIdentity3
                  `cast`
                (forall (a :: <*>_N).
                 <a -> a -> a>_R
                 ->_R <Main.Identity a>_R
                 ->_R Main.N:Identity[0] <a>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$clength :: Main.Identity a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (xs :: Main.Identity a) -> GHC.Types.I# 1#) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cmaximum ::
    GHC.Classes.Ord a => Main.Identity a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFoldableIdentity2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R <Main.Identity a>_R
                 ->_R Main.N:Identity[0] <a>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$cnull :: Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (t1 :: Main.Identity a) -> GHC.Types.False) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$csum :: GHC.Num.Num a => Main.Identity a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFoldableIdentity1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Main.Identity a>_R
                 ->_R Main.N:Identity[0] <a>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFoldableIdentity_$ctoList :: Main.Identity a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Main.Identity a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Main.$fFoldableIdentity_$cfoldr @ a @ b c n t1)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFunctorIdentity :: GHC.Base.Functor Main.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fFunctorIdentity_$cfmap
                  Main.$fFunctorIdentity_$c<$ -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFunctorIdentity1 :: a -> Main.Identity b -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (eta :: a) (ds :: Main.Identity b) -> eta) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFunctorIdentity2 :: (a -> b) -> Main.Identity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (f :: a -> b) (ds :: Main.Identity a) ->
                 f ds `cast` (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFunctorIdentity_$c<$ :: a -> Main.Identity b -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Main.$fFunctorIdentity1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <Main.Identity b>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fFunctorIdentity_$cfmap ::
    (a -> b) -> Main.Identity a -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFunctorIdentity2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Main.Identity a>_R
                 ->_R Sym (Main.N:Identity[0] <b>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity ::
    GHC.Classes.Ord a => GHC.Classes.Ord (Main.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dOrd :: GHC.Classes.Ord a).
                  @ (Main.Identity a)
                  (Main.$fOrdIdentity_$cp1Ord @ a $dOrd)
                  (Main.$fOrdIdentity_$ccompare @ a $dOrd)
                  (Main.$fOrdIdentity_$c< @ a $dOrd)
                  (Main.$fOrdIdentity_$c<= @ a $dOrd)
                  (Main.$fOrdIdentity_$c> @ a $dOrd)
                  (Main.$fOrdIdentity_$c>= @ a $dOrd)
                  (Main.$fOrdIdentity_$cmax @ a $dOrd)
                  (Main.$fOrdIdentity_$cmin @ a $dOrd) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$c< ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$c<= ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$c> ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$c>= ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$ccompare ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.compare
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Ordering>_R) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$cmax ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> Main.Identity a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.max
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$cmin ::
    GHC.Classes.Ord a =>
    Main.Identity a -> Main.Identity a -> Main.Identity a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.min
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fOrdIdentity_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Main.Identity a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Main.$fEqIdentity @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fShowIdentity ::
    GHC.Show.Show a => GHC.Show.Show (Main.Identity a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Main.Identity a)
                  (Main.$fShowIdentity_$cshowsPrec @ a $dShow)
                  (Main.$fShowIdentity_$cshow @ a $dShow)
                  (Main.$fShowIdentity_$cshowList @ a $dShow) -}
b791430c4b353c757a98502218c504b8
  $fShowIdentity1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6bf4c5970a6280d05058072047b964f6
  $fShowIdentity2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Identity "#) -}
870eafa702d67223a5577c16ce014697
  $fShowIdentity3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fShowIdentity_$cshow ::
    GHC.Show.Show a => Main.Identity a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Main.Identity a) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowIdentity2)
                   (GHC.Show.showsPrec
                      @ a
                      $dShow
                      Main.$fShowIdentity3
                      x `cast` (Main.N:Identity[0] <a>_R)
                      (GHC.Types.[] @ GHC.Types.Char))) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fShowIdentity_$cshowList ::
    GHC.Show.Show a => [Main.Identity a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Main.Identity a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Identity a)
                   (Main.$fShowIdentity_$cshowsPrec @ a $dShow Main.$fShowIdentity1)
                   eta
                   eta1) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fShowIdentity_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Identity a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec @ a w ww1 w2 }) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fTraversableIdentity :: Data.Traversable.Traversable Main.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fFunctorIdentity
                  Main.$fFoldableIdentity
                  Main.$fTraversableIdentity_$ctraverse
                  Main.$fTraversableIdentity_$csequenceA
                  Main.$fTraversableIdentity_$cmapM
                  Main.$fTraversableIdentity_$csequence -}
7caef6a0780608b66f096fb737fbdbaa
  $fTraversableIdentity1 :: b -> b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ b (tpl :: b) -> tpl) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fTraversableIdentity_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> Main.Identity a -> m (Main.Identity b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: Main.Identity a) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   @ b
                   @ (Main.Identity b)
                   (Main.$fTraversableIdentity1 @ b)
                     `cast`
                   (<b>_R ->_R Sym (Main.N:Identity[0] <b>_R))
                   (eta eta1 `cast` (Main.N:Identity[0] <a>_R))) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fTraversableIdentity_$csequence ::
    GHC.Base.Monad m => Main.Identity (m a) -> m (Main.Identity a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: Main.Identity (m a)) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   @ a
                   @ (Main.Identity a)
                   (Main.$fTraversableIdentity1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Main.N:Identity[0] <a>_R))
                   eta `cast` (Main.N:Identity[0] <m a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fTraversableIdentity_$csequenceA ::
    GHC.Base.Applicative f =>
    Main.Identity (f a) -> f (Main.Identity a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Main.Identity (f a)) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ a
                   @ (Main.Identity a)
                   (Main.$fTraversableIdentity1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Main.N:Identity[0] <a>_R))
                   eta `cast` (Main.N:Identity[0] <f a>_R)) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $fTraversableIdentity_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Main.Identity a -> f (Main.Identity b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: Main.Identity a) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ b
                   @ (Main.Identity b)
                   (Main.$fTraversableIdentity1 @ b)
                     `cast`
                   (<b>_R ->_R Sym (Main.N:Identity[0] <b>_R))
                   (eta eta1 `cast` (Main.N:Identity[0] <a>_R))) -}
fb6ed5929bece2c052127313cb24c106
  $tc'Identity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2029112138846393583##
                   2905385520651452197##
                   Main.$trModule
                   Main.$tc'Identity1) -}
d66c2f8db5a22ef38960484a4b9f37e2
  $tc'Identity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Identity"#) -}
7f9137da72f6c5793b3d621bfaad5de1
  $tcIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1219351100840430795##
                   4195889340468339127##
                   Main.$trModule
                   Main.$tcIdentity1) -}
8223c0a29bd099943619ea59d112c6ea
  $tcIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Identity"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.Identity a) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       Main.$fShowIdentity3
                       w1 `cast` (Main.N:Identity[0] <a>_R)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Main.$fShowIdentity2 (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowIdentity2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }) -}
eff7c7b3f1099a43bf7f6565801d2d6e
  newtype Identity a = Identity a
029b6365df0d88571104274d61fb128a
  main :: GHC.Types.IO ()
  {- Strictness: x -}
f94e2cea9aa73c89006716fc76a7f93e
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1 @ () Main.main) -}
instance GHC.Classes.Eq [Main.Identity] = Main.$fEqIdentity
instance Data.Foldable.Foldable [Main.Identity]
  = Main.$fFoldableIdentity
instance GHC.Base.Functor [Main.Identity] = Main.$fFunctorIdentity
instance GHC.Classes.Ord [Main.Identity] = Main.$fOrdIdentity
instance GHC.Show.Show [Main.Identity] = Main.$fShowIdentity
instance Data.Traversable.Traversable [Main.Identity]
  = Main.$fTraversableIdentity
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

